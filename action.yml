name: 'Connect to Twingate'
description: 'Connects to Twingate protected resources from your Github Action workflow'
branding:
  icon: 'arrow-right-circle'
  color: 'black'
inputs:
  service-key:
    description: 'Twingate Service Key'
    required: true
  debug:
    description: 'Enable debug output'
    required: false
    default: "false"
  cache-version:
    description: 'Cache version suffix for invalidating cached packages'
    required: false
    default: "3"
  cache:
    description: 'Enable caching of Twingate packages'
    required: false
    default: "true"
runs:
  using: "composite"
  steps:
    - name: Error if unsupported runner.os
      if: runner.os != 'Linux' && runner.os != 'Windows'
      shell: bash
      run: |
        error_log() {
          echo "[ERROR] $1"
        }
        error_log "Unsupported Runner OS: ${{ runner.os }}"
        exit 1

    - name: Get latest Twingate version (Linux)
      if: runner.os == 'Linux' && inputs.cache == 'true'
      id: twingate-version-linux
      shell: bash
      run: |
        debug_log() {
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "[DEBUG] $1"
          fi
        }

        VERSION=$(curl -sf https://packages.twingate.com/apt/Packages | awk '/^Package: twingate$/,/^Version:/ {if (/^Version:/) print $2}' | sort -V | tail -1)
        if [ -z "$VERSION" ]; then
          debug_log "Failed to fetch version, proceeding without cache"
          echo "version=unknown" >> $GITHUB_OUTPUT
        else
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          debug_log "Latest Twingate version: $VERSION"
        fi

        # Get OS version for cache key
        OS_VERSION=$(grep VERSION_ID /etc/os-release | cut -d= -f2 | tr -d '"')
        echo "os_version=$OS_VERSION" >> $GITHUB_OUTPUT

    - name: Get latest Twingate version (Windows)
      if: runner.os == 'Windows' && inputs.cache == 'true'
      id: twingate-version-windows
      shell: powershell
      run: |
        function debug_log {
          param([string]$Message)
          if ('${{ inputs.debug }}' -eq 'true') {
            Write-Host "[DEBUG] $Message"
          }
        }

        try {
          $msiUrl = "https://api.twingate.com/download/windows?installer=msi"
          debug_log "Fetching from $msiUrl"

          $response = Invoke-WebRequest -Uri $msiUrl -Method Get -UseBasicParsing -MaximumRedirection 0 -ErrorAction SilentlyContinue
          $finalUrl = $response.Headers.Location

          debug_log "Redirect location: $finalUrl"

          if ($finalUrl -match 'versions/([\d.]+)/') {
            $version = $matches[1]
            debug_log "Latest Twingate version: $version"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "version=$version"
          } else {
            debug_log "Could not extract version from URL"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "version=unknown"
          }
        } catch {
          debug_log "Error: $_"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "version=unknown"
        }

        try {
          $osVersion = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuildNumber
        } catch {
          debug_log "Failed to read Windows build number from registry: $_"
          $osVersion = "unknown"
        }
        debug_log "Windows build number: $osVersion"
        Add-Content -Path $env:GITHUB_OUTPUT -Value "os_version=$osVersion"

    - name: Setup cache directory (Linux)
      if: runner.os == 'Linux' && inputs.cache == 'true' && steps.twingate-version-linux.outputs.version != 'unknown'
      shell: bash
      run: mkdir -p ~/.twingate-cache

    - name: Cache Twingate package and dependencies (Linux)
      if: runner.os == 'Linux' && inputs.cache == 'true' && steps.twingate-version-linux.outputs.version != 'unknown'
      uses: actions/cache@v5
      id: cache-twingate-linux
      with:
        path: ~/.twingate-cache
        key: twingate-cache-v${{ inputs.cache-version }}-${{ runner.os }}-${{ runner.arch }}-${{ steps.twingate-version-linux.outputs.os_version }}-v${{ steps.twingate-version-linux.outputs.version }}

    - name: Setup cache directory (Windows)
      if: runner.os == 'Windows' && inputs.cache == 'true' && steps.twingate-version-windows.outputs.version != 'unknown'
      shell: powershell
      run: |
        $cacheDir = "${{ runner.temp }}\twingate-cache"
        if (-not (Test-Path $cacheDir)) {
          New-Item -ItemType Directory -Path $cacheDir -Force | Out-Null
        }
        if ('${{ inputs.debug }}' -eq 'true') { Write-Host "[DEBUG] Cache directory: $cacheDir" }

    - name: Cache Twingate MSI (Windows)
      if: runner.os == 'Windows' && inputs.cache == 'true' && steps.twingate-version-windows.outputs.version != 'unknown'
      uses: actions/cache@v5
      id: cache-twingate-windows
      with:
        path: ${{ runner.temp }}\twingate-cache
        key: twingate-cache-v${{ inputs.cache-version }}-${{ runner.os }}-${{ runner.arch }}-${{ steps.twingate-version-windows.outputs.os_version }}-v${{ steps.twingate-version-windows.outputs.version }}

    - name: Validate cached package (Linux)
      if: runner.os == 'Linux' && inputs.cache == 'true' && steps.cache-twingate-linux.outputs.cache-hit == 'true'
      id: validate-cache-linux
      shell: bash
      run: |
        debug_log() {
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "[DEBUG] $1"
          fi
        }

        DEB_FILE=$(ls ~/.twingate-cache/twingate*.deb 2>/dev/null | head -1)
        if [ -z "$DEB_FILE" ]; then
          debug_log "No .deb file found in cache"
          echo "valid=false" >> $GITHUB_OUTPUT
        elif ! dpkg-deb --info "$DEB_FILE" >/dev/null 2>&1; then
          debug_log "Cached .deb is corrupted"
          rm -rf ~/.twingate-cache/*
          echo "valid=false" >> $GITHUB_OUTPUT
        else
          debug_log "Cache is valid"
          echo "valid=true" >> $GITHUB_OUTPUT
        fi

    - name: Validate cached MSI (Windows)
      if: runner.os == 'Windows' && inputs.cache == 'true' && steps.cache-twingate-windows.outputs.cache-hit == 'true'
      id: validate-cache-windows
      shell: powershell
      run: |
        function debug_log {
          param([string]$Message)
          if ('${{ inputs.debug }}' -eq 'true') {
            Write-Host "[DEBUG] $Message"
          }
        }

        $cacheDir = "${{ runner.temp }}\twingate-cache"
        $msiFiles = Get-ChildItem -Path $cacheDir -Filter "twingate*.msi" -ErrorAction SilentlyContinue

        if ($msiFiles.Count -eq 0) {
          debug_log "No MSI file found in cache"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=false"
        } else {
          try {
            $msiFile = $msiFiles[0].FullName

            # Try to get MSI properties - this validates the MSI file
            $msiInfo = Get-ItemProperty -Path $msiFile
            if (-not $msiInfo) {
              debug_log "Cached MSI is corrupted"
              Remove-Item -Path $cacheDir -Recurse -Force -ErrorAction SilentlyContinue
              Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=false"
            } else {
              debug_log "Cache is valid"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=true"
            }
          } catch {
            debug_log "Cached MSI is corrupted: $_"
            Remove-Item -Path $cacheDir -Recurse -Force -ErrorAction SilentlyContinue
            Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=false"
          }
        }

    - name: Install Twingate from cache (Linux)
      if: runner.os == 'Linux' && inputs.cache == 'true' && steps.validate-cache-linux.outputs.valid == 'true'
      shell: bash
      run: |
        debug_log() {
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "[DEBUG] $1"
          fi
        }

        debug_log "Installing Twingate from cache"
        # Install all packages from cache directory (twingate + dependencies)
        sudo dpkg -i ~/.twingate-cache/*.deb || true
        sudo apt-get install -f -yq

    - name: Copy cached MSI to working directory (Windows)
      if: runner.os == 'Windows' && inputs.cache == 'true' && steps.validate-cache-windows.outputs.valid == 'true'
      shell: powershell
      run: |
        function debug_log {
          param([string]$Message)
          if ('${{ inputs.debug }}' -eq 'true') {
            Write-Host "[DEBUG] $Message"
          }
        }

        debug_log "Copying cached MSI to working directory"
        $cacheDir = "${{ runner.temp }}\twingate-cache"
        $msiFile = Get-ChildItem -Path $cacheDir -Filter "twingate*.msi" | Select-Object -First 1

        if ($msiFile) {
          debug_log "Using cached MSI: $($msiFile.Name)"
          Copy-Item -Path $msiFile.FullName -Destination ".\twingate_client.msi" -Force
        } else {
          debug_log "No cached MSI found, will download"
          exit 1
        }

    - name: Install Twingate (Linux)
      if: runner.os == 'Linux' && (inputs.cache != 'true' || steps.cache-twingate-linux.outputs.cache-hit != 'true' || steps.validate-cache-linux.outputs.valid != 'true' || steps.twingate-version-linux.outputs.version == 'unknown')
      shell: bash
      run: |
        # Import Twingate GPG key for signature verification
        curl -fsSL https://packages.twingate.com/apt/gpg.key | sudo gpg --dearmor -o /usr/share/keyrings/twingate-client-keyring.gpg

        # Add Twingate repository with GPG key verification
        echo "deb [signed-by=/usr/share/keyrings/twingate-client-keyring.gpg] https://packages.twingate.com/apt/ * *" | sudo tee /etc/apt/sources.list.d/twingate.list

        sudo apt update
        sudo apt-get update -o Dir::Etc::sourcelist="sources.list.d/twingate.list" -o Dir::Etc::sourceparts="-" -o APT::Get::List-Cleanup="0"

        # Download all packages to cache if caching is enabled
        if [ "${{ steps.twingate-version-linux.outputs.version }}" != "unknown" ]; then
          mkdir -p ~/.twingate-cache
          # Download Twingate and all dependencies to cache directory
          sudo apt-get install -yq --download-only -o Dir::Cache::Archives="$HOME/.twingate-cache" twingate
          # Install to resolve any missing dependencies, then download them
          sudo apt-get install -yq --download-only -o Dir::Cache::Archives="$HOME/.twingate-cache" -f
          # Fix permissions so cache action can save files
          sudo chown -R "$(id -u)":"$(id -g)" "$HOME/.twingate-cache"
        fi

        sudo apt install -yq twingate

    - name: Download and cache Twingate MSI (Windows)
      if: runner.os == 'Windows' && (inputs.cache != 'true' || steps.cache-twingate-windows.outputs.cache-hit != 'true' || steps.validate-cache-windows.outputs.valid != 'true' || steps.twingate-version-windows.outputs.version == 'unknown')
      shell: powershell
      run: |
        function debug_log {
          param([string]$Message)
          if ('${{ inputs.debug }}' -eq 'true') {
            Write-Host "[DEBUG] $Message"
          }
        }

        # Download MSI
        $msiUrl = "https://api.twingate.com/download/windows?installer=msi"
        debug_log "Downloading Twingate from $msiUrl"
        Invoke-WebRequest -Uri $msiUrl -OutFile ".\twingate_client.msi"

        # Cache the MSI if caching is enabled
        if ('${{ steps.twingate-version-windows.outputs.version }}' -ne 'unknown') {
          $cacheDir = "${{ runner.temp }}\twingate-cache"
          if (-not (Test-Path $cacheDir)) {
            New-Item -ItemType Directory -Path $cacheDir -Force | Out-Null
          }

          $version = '${{ steps.twingate-version-windows.outputs.version }}'
          $msiCachePath = "$cacheDir\twingate-client-$version.msi"
          debug_log "Caching MSI to $msiCachePath"
          Copy-Item -Path ".\twingate_client.msi" -Destination $msiCachePath -Force
          Get-ChildItem -Path $cacheDir | ForEach-Object { debug_log "Cache: $($_.Name) ($($_.Length) bytes)" }
        }
    
    - name: Setup and start Twingate (Linux)
      if: runner.os == 'Linux'
      shell: bash
      run: |
        info_log() {
          echo "[INFO] $1"
        }

        debug_log() {
          if [ "${{ inputs.debug }}" = "true" ]; then
            echo "[DEBUG] $1"
          fi
        }

        error_log() {
          echo "[ERROR] $1"
        }

        echo '${{ inputs.service-key }}' | sudo twingate setup --headless -
        MAX_RETRIES=5
        WAIT_TIME=5
        n=0

        while [ $n -lt $MAX_RETRIES ]; do
          info_log "Starting Twingate service..."
          set +xe
          twingate start

          info_log "Waiting $WAIT_TIME seconds for Twingate service to start..."
          sleep $WAIT_TIME

          status=$(twingate status)
          info_log "Twingate service status: '$status'"

          if [ "$status" = "online" ]; then
            info_log "Twingate service is connected."
            if [ "${{ inputs.debug }}" = "true" ]; then
              twingate resources
            fi
            break
          else
            twingate stop
            if [ "${{ inputs.debug }}" = "true" ]; then
              journalctl -u twingate --no-pager
            fi
          fi

          # Increment the retry counter and wait time
          n=$((n+1))
          WAIT_TIME=$((WAIT_TIME+5))

          info_log "Twingate service is not connected. Retrying..."
        done

        if [ $n -eq $MAX_RETRIES ]; then
          error_log "Twingate service failed to connect."
          exit 1
        fi

    - name: Setup and Start Twingate (Windows)
      if: runner.os == 'Windows'
      shell: powershell
      run: |
        function info_log {
          param([string]$Message)
          Write-Host "[INFO] $Message"
        }

        function debug_log {
          param([string]$Message)
          if ('${{ inputs.debug }}' -eq 'true') {
            Write-Host "[DEBUG] $Message"
          }
        }

        function error_log {
          param([string]$Message)
          Write-Host "[ERROR] $Message"
        }

        # Install Twingate client and start service
        Set-Content .\key.json  '${{ inputs.service-key }}'
        $key_path = (Get-Item .\key.json | Resolve-Path).ProviderPath

        info_log "Installing Twingate client..."
        Start-Process msiexec.exe -Wait -ArgumentList "/i twingate_client.msi /l*v install.log log_level=debug service_secret=$key_path /quiet"

        info_log "Starting Twingate service..."
        Start-Sleep -Seconds 1
        Start-Service twingate.service

        info_log "Waiting for service to initialize..."
        Start-Sleep -Seconds 14
        $service = Get-Service twingate.service
        if ($service.Status -eq 'Running') {
          info_log "Twingate service started successfully"
        } else {
          error_log "Twingate service failed to start"
          exit 1
        }