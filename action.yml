name: 'Connect to Twingate'
description: 'Connects to Twingate protected resources from your Github Action workflow'
branding:
  icon: 'arrow-right-circle'
  color: 'black'
inputs:
  service-key:
    description: 'Twingate Service Key'
    required: true
  debug:
    description: 'Enable debug output'
    required: false
    default: "false"
  cache-version:
    description: 'Cache version suffix for invalidating cached packages'
    required: false
    default: "3"
  cache:
    description: 'Enable caching of Twingate packages'
    required: false
    default: "true"
runs:
  using: "composite"
  steps:
    - name: Error if unsupported runner.os
      if: runner.os != 'Linux' && runner.os != 'Windows'
      shell: bash
      run: |
        source ./scripts/logging.sh
        log ERROR "Unsupported Runner OS: ${{ runner.os }}"
        exit 1

    - name: Get latest Twingate version (Linux)
      if: runner.os == 'Linux' && inputs.cache == 'true'
      id: twingate-version-linux
      shell: bash
      run: |
        export DEBUG_MODE='${{ inputs.debug }}'
        source ./scripts/logging.sh

        VERSION=$(curl -sf https://packages.twingate.com/apt/Packages | awk '/^Package: twingate$/,/^Version:/ {if (/^Version:/) print $2}' | sort -V | tail -1)
        if [ -z "$VERSION" ]; then
          log DEBUG "Failed to fetch version, proceeding without cache"
          echo "version=unknown" >> $GITHUB_OUTPUT
        else
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          log DEBUG "Latest Twingate version: $VERSION"
        fi

        # Get OS version for cache key
        OS_VERSION=$(grep VERSION_ID /etc/os-release | cut -d= -f2 | tr -d '"')
        echo "os_version=$OS_VERSION" >> $GITHUB_OUTPUT

    - name: Get latest Twingate version (Windows)
      if: runner.os == 'Windows' && inputs.cache == 'true'
      id: twingate-version-windows
      shell: powershell
      run: |
        $env:DEBUG_MODE = '${{ inputs.debug }}'
        . ./scripts/logging.ps1

        try {
          $msiUrl = "https://api.twingate.com/download/windows?installer=msi"
          log DEBUG "Fetching from $msiUrl"

          $response = Invoke-WebRequest -Uri $msiUrl -Method Get -UseBasicParsing -MaximumRedirection 0 -ErrorAction SilentlyContinue
          $finalUrl = $response.Headers.Location

          log DEBUG "Redirect location: $finalUrl"

          if ($finalUrl -match 'versions/([\d.]+)/') {
            $version = $matches[1]
            log DEBUG "Latest Twingate version: $version"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "version=$version"
          } else {
            log DEBUG "Could not extract version from URL"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "version=unknown"
          }
        } catch {
          log DEBUG "Error: $_"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "version=unknown"
        }

        try {
          $osVersion = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuildNumber
        } catch {
          log DEBUG "Failed to read Windows build number from registry: $_"
          $osVersion = "unknown"
        }
        log DEBUG "Windows build number: $osVersion"
        Add-Content -Path $env:GITHUB_OUTPUT -Value "os_version=$osVersion"

    - name: Setup cache directory (Linux)
      if: runner.os == 'Linux' && inputs.cache == 'true' && steps.twingate-version-linux.outputs.version != 'unknown'
      shell: bash
      run: mkdir -p ~/.twingate-cache

    - name: Cache Twingate package and dependencies (Linux)
      if: runner.os == 'Linux' && inputs.cache == 'true' && steps.twingate-version-linux.outputs.version != 'unknown'
      uses: actions/cache@v5
      id: cache-twingate-linux
      with:
        path: ~/.twingate-cache
        key: twingate-cache-v${{ inputs.cache-version }}-${{ runner.os }}-${{ runner.arch }}-${{ steps.twingate-version-linux.outputs.os_version }}-v${{ steps.twingate-version-linux.outputs.version }}

    - name: Setup cache directory (Windows)
      if: runner.os == 'Windows' && inputs.cache == 'true' && steps.twingate-version-windows.outputs.version != 'unknown'
      shell: powershell
      run: |
        $cacheDir = "${{ runner.temp }}\twingate-cache"
        if (-not (Test-Path $cacheDir)) {
          New-Item -ItemType Directory -Path $cacheDir -Force | Out-Null
        }
        if ('${{ inputs.debug }}' -eq 'true') { Write-Host "[DEBUG] Cache directory: $cacheDir" }

    - name: Cache Twingate MSI (Windows)
      if: runner.os == 'Windows' && inputs.cache == 'true' && steps.twingate-version-windows.outputs.version != 'unknown'
      uses: actions/cache@v5
      id: cache-twingate-windows
      with:
        path: ${{ runner.temp }}\twingate-cache
        key: twingate-cache-v${{ inputs.cache-version }}-${{ runner.os }}-${{ runner.arch }}-${{ steps.twingate-version-windows.outputs.os_version }}-v${{ steps.twingate-version-windows.outputs.version }}

    - name: Validate cached package (Linux)
      if: runner.os == 'Linux' && inputs.cache == 'true' && steps.cache-twingate-linux.outputs.cache-hit == 'true'
      id: validate-cache-linux
      shell: bash
      run: |
        export DEBUG_MODE='${{ inputs.debug }}'
        source ./scripts/logging.sh

        DEB_FILE=$(ls ~/.twingate-cache/twingate*.deb 2>/dev/null | head -1)
        if [ -z "$DEB_FILE" ]; then
          log DEBUG "No .deb file found in cache"
          echo "valid=false" >> $GITHUB_OUTPUT
        elif ! dpkg-deb --info "$DEB_FILE" >/dev/null 2>&1; then
          log DEBUG "Cached .deb is corrupted"
          rm -rf ~/.twingate-cache/*
          echo "valid=false" >> $GITHUB_OUTPUT
        else
          log DEBUG "Cache is valid"
          echo "valid=true" >> $GITHUB_OUTPUT
        fi

    - name: Validate cached MSI (Windows)
      if: runner.os == 'Windows' && inputs.cache == 'true' && steps.cache-twingate-windows.outputs.cache-hit == 'true'
      id: validate-cache-windows
      shell: powershell
      run: |
        $env:DEBUG_MODE = '${{ inputs.debug }}'
        . ./scripts/logging.ps1

        $cacheDir = "${{ runner.temp }}\twingate-cache"
        $msiFiles = Get-ChildItem -Path $cacheDir -Filter "twingate*.msi" -ErrorAction SilentlyContinue

        if ($msiFiles.Count -eq 0) {
          log DEBUG "No MSI file found in cache"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=false"
        } else {
          try {
            $msiFile = $msiFiles[0].FullName

            # Try to get MSI properties - this validates the MSI file
            $msiInfo = Get-ItemProperty -Path $msiFile
            if (-not $msiInfo) {
              log DEBUG "Cached MSI is corrupted"
              Remove-Item -Path $cacheDir -Recurse -Force -ErrorAction SilentlyContinue
              Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=false"
            } else {
              log DEBUG "Cache is valid"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=true"
            }
          } catch {
            log DEBUG "Cached MSI is corrupted: $_"
            Remove-Item -Path $cacheDir -Recurse -Force -ErrorAction SilentlyContinue
            Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=false"
          }
        }

    - name: Install Twingate from cache (Linux)
      if: runner.os == 'Linux' && inputs.cache == 'true' && steps.validate-cache-linux.outputs.valid == 'true'
      shell: bash
      run: |
        export DEBUG_MODE='${{ inputs.debug }}'
        source ./scripts/logging.sh

        log DEBUG "Installing Twingate from cache"
        # Install all packages from cache directory (twingate + dependencies)
        sudo dpkg -i ~/.twingate-cache/*.deb || true
        sudo apt-get install -f -yq

    - name: Copy cached MSI to working directory (Windows)
      if: runner.os == 'Windows' && inputs.cache == 'true' && steps.validate-cache-windows.outputs.valid == 'true'
      shell: powershell
      run: |
        $env:DEBUG_MODE = '${{ inputs.debug }}'
        . ./scripts/logging.ps1

        log DEBUG "Copying cached MSI to working directory"
        $cacheDir = "${{ runner.temp }}\twingate-cache"
        $msiFile = Get-ChildItem -Path $cacheDir -Filter "twingate*.msi" | Select-Object -First 1

        if ($msiFile) {
          log DEBUG "Using cached MSI: $($msiFile.Name)"
          Copy-Item -Path $msiFile.FullName -Destination ".\twingate_client.msi" -Force
        } else {
          log DEBUG "No cached MSI found, will download"
          exit 1
        }

    - name: Install Twingate (Linux)
      if: runner.os == 'Linux' && (inputs.cache != 'true' || steps.cache-twingate-linux.outputs.cache-hit != 'true' || steps.validate-cache-linux.outputs.valid != 'true' || steps.twingate-version-linux.outputs.version == 'unknown')
      shell: bash
      run: |
        # Import Twingate GPG key for signature verification
        curl -fsSL https://packages.twingate.com/apt/gpg.key | sudo gpg --dearmor -o /usr/share/keyrings/twingate-client-keyring.gpg

        # Add Twingate repository with GPG key verification
        echo "deb [signed-by=/usr/share/keyrings/twingate-client-keyring.gpg] https://packages.twingate.com/apt/ * *" | sudo tee /etc/apt/sources.list.d/twingate.list

        sudo apt update
        sudo apt-get update -o Dir::Etc::sourcelist="sources.list.d/twingate.list" -o Dir::Etc::sourceparts="-" -o APT::Get::List-Cleanup="0"

        # Download all packages to cache if caching is enabled
        if [ "${{ steps.twingate-version-linux.outputs.version }}" != "unknown" ]; then
          mkdir -p ~/.twingate-cache
          # Download Twingate and all dependencies to cache directory
          sudo apt-get install -yq --download-only -o Dir::Cache::Archives="$HOME/.twingate-cache" twingate
          # Install to resolve any missing dependencies, then download them
          sudo apt-get install -yq --download-only -o Dir::Cache::Archives="$HOME/.twingate-cache" -f
          # Fix permissions so cache action can save files
          sudo chown -R "$(id -u)":"$(id -g)" "$HOME/.twingate-cache"
        fi

        sudo apt install -yq twingate

    - name: Download and cache Twingate MSI (Windows)
      if: runner.os == 'Windows' && (inputs.cache != 'true' || steps.cache-twingate-windows.outputs.cache-hit != 'true' || steps.validate-cache-windows.outputs.valid != 'true' || steps.twingate-version-windows.outputs.version == 'unknown')
      shell: powershell
      run: |
        $env:DEBUG_MODE = '${{ inputs.debug }}'
        . ./scripts/logging.ps1

        # Download MSI
        $msiUrl = "https://api.twingate.com/download/windows?installer=msi"
        log DEBUG "Downloading Twingate from $msiUrl"
        Invoke-WebRequest -Uri $msiUrl -OutFile ".\twingate_client.msi"

        # Cache the MSI if caching is enabled
        if ('${{ steps.twingate-version-windows.outputs.version }}' -ne 'unknown') {
          $cacheDir = "${{ runner.temp }}\twingate-cache"
          if (-not (Test-Path $cacheDir)) {
            New-Item -ItemType Directory -Path $cacheDir -Force | Out-Null
          }

          $version = '${{ steps.twingate-version-windows.outputs.version }}'
          $msiCachePath = "$cacheDir\twingate-client-$version.msi"
          log DEBUG "Caching MSI to $msiCachePath"
          Copy-Item -Path ".\twingate_client.msi" -Destination $msiCachePath -Force
          Get-ChildItem -Path $cacheDir | ForEach-Object { log DEBUG "Cache: $($_.Name) ($($_.Length) bytes)" }
        }
    
    - name: Setup and start Twingate (Linux)
      if: runner.os == 'Linux'
      shell: bash
      run: |
        export DEBUG_MODE='${{ inputs.debug }}'
        source ./scripts/logging.sh

        echo '${{ inputs.service-key }}' | sudo twingate setup --headless -
        MAX_RETRIES=5
        WAIT_TIME=5
        n=0

        while [ $n -lt $MAX_RETRIES ]; do
          log INFO "Starting Twingate service..."
          set +xe
          twingate start

          log INFO "Waiting $WAIT_TIME seconds for Twingate service to start..."
          sleep $WAIT_TIME

          status=$(twingate status)
          log INFO "Twingate service status: '$status'"

          if [ "$status" = "online" ]; then
            log INFO "Twingate service is connected."
            if [ "${{ inputs.debug }}" = "true" ]; then
              twingate resources
            fi
            break
          else
            twingate stop
            if [ "${{ inputs.debug }}" = "true" ]; then
              journalctl -u twingate --no-pager
            fi
          fi

          # Increment the retry counter and wait time
          n=$((n+1))
          WAIT_TIME=$((WAIT_TIME+5))

          log INFO "Twingate service is not connected. Retrying..."
        done

        if [ $n -eq $MAX_RETRIES ]; then
          log ERROR "Twingate service failed to connect."
          exit 1
        fi

    - name: Setup and Start Twingate (Windows)
      if: runner.os == 'Windows'
      shell: powershell
      run: |
        $env:DEBUG_MODE = '${{ inputs.debug }}'
        . ./scripts/logging.ps1

        # Install Twingate client and start service
        Set-Content .\key.json  '${{ inputs.service-key }}'
        $key_path = (Get-Item .\key.json | Resolve-Path).ProviderPath

        try {
          log INFO "Installing Twingate client..."
          Start-Process msiexec.exe -Wait -ArgumentList "/i twingate_client.msi /l*v install.log log_level=debug service_secret=$key_path /quiet"
        } finally {
          # Clean up the secret file immediately after MSI exits
          if (Test-Path .\key.json) {
            Remove-Item .\key.json -Force -ErrorAction SilentlyContinue
            log DEBUG "Cleaned up temporary secret file"
          }
        }

        # Start Twingate service with comprehensive retry logic
        $MAX_RETRIES = 5
        $WAIT_TIME = 5
        $retry_count = 0
        $service_started = $false
        $SERVICE_NAME = 'twingate.service'

        while ($retry_count -lt $MAX_RETRIES) {
          log INFO "Starting Twingate service (attempt $($retry_count + 1)/$MAX_RETRIES)..."

          # Check if service exists
          try {
            $service = Get-Service $SERVICE_NAME -ErrorAction Stop
            log DEBUG "Service found: $($service.Name)"
          } catch {
            log ERROR "Service '$SERVICE_NAME' not found: $_"
            exit 1
          }

          # Attempt to start the service
          try {
            if ($service.Status -eq 'Stopped') {
              Start-Service $SERVICE_NAME -ErrorAction Stop
              log INFO "Service start command executed successfully"
            } elseif ($service.Status -eq 'Running') {
              log DEBUG "Service is already in Running state"
            } else {
              log WARNING "Service is in $($service.Status) state, attempting to start anyway"
              Start-Service $SERVICE_NAME -ErrorAction Stop
            }
          } catch {
            log ERROR "Failed to start service: $_"
            $retry_count++
            if ($retry_count -lt $MAX_RETRIES) {
              log INFO "Retrying service start in $WAIT_TIME seconds..."
              Start-Sleep -Seconds $WAIT_TIME
              $WAIT_TIME += 5
              continue
            } else {
              break
            }
          }

          # Verify service is actually running
          $status_check_attempts = 3
          $status_check_delay = 2
          $final_status = $null

          for ($i = 0; $i -lt $status_check_attempts; $i++) {
            try {
              $service = Get-Service $SERVICE_NAME -ErrorAction Stop
              $final_status = $service.Status
              log INFO "Service status check #$($i + 1): $final_status"

              if ($final_status -eq 'Running') {
                log DEBUG "Service confirmed as Running"
                break
              } elseif ($i -lt ($status_check_attempts - 1)) {
                log DEBUG "Service not yet Running, waiting $status_check_delay seconds before next check..."
                Start-Sleep -Seconds $status_check_delay
              }
            } catch {
              log ERROR "Failed to check service status: $_"
              $final_status = 'Unknown'
            }
          }

          if ($final_status -eq 'Running') {
            log INFO "Twingate service is running successfully."
            if ($env:DEBUG_MODE -eq 'true') {
              try {
                $serviceDetails = Get-Service $SERVICE_NAME -ErrorAction Stop
                log DEBUG "Service details: Name=$($serviceDetails.Name), Status=$($serviceDetails.Status), DisplayName=$($serviceDetails.DisplayName)"
              } catch {
                log DEBUG "Could not retrieve service details: $_"
              }
            }
            $service_started = $true
            break
          } else {
            log ERROR "Service status is '$final_status', not Running"

            # Attempt to stop the service before retrying
            try {
              $service = Get-Service $SERVICE_NAME -ErrorAction Stop
              if ($service.Status -ne 'Stopped') {
                log INFO "Stopping service before retry..."
                Stop-Service $SERVICE_NAME -ErrorAction Stop
                Start-Sleep -Seconds 2
              }
            } catch {
              log DEBUG "Could not stop service: $_"
            }
          }

          # Increment retry counter and wait time
          $retry_count++
          $WAIT_TIME += 5

          if ($retry_count -lt $MAX_RETRIES) {
            log INFO "Twingate service is not running. Retrying in $WAIT_TIME seconds..."
          }
        }

        if (-not $service_started) {
          log ERROR "Twingate service failed to start after $MAX_RETRIES retries (waiting up to 75 seconds total)"
          exit 1
        }

        log INFO "Twingate service startup completed successfully"