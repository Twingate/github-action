name: 'Connect to Twingate'
description: 'Connects to Twingate protected resources from your Github Action workflow'
branding:
  icon: 'arrow-right-circle'
  color: 'black'
inputs:
  service-key:
    description: 'Twingate Service Key'
    required: true
  debug:
    description: 'Enable debug output'
    required: false
    default: "false"
runs:
  using: "composite"
  steps:
    - name: Error if unsupported runner.os
      if: runner.os != 'Linux' && runner.os != 'Windows'
      shell: bash
      run: |
        echo "Unsupported Runner OS: ${{ runner.os }}"
        exit 1

    - name: Get latest Twingate version (Linux)
      if: runner.os == 'Linux'
      id: twingate-version-linux
      shell: bash
      run: |
        VERSION=$(curl -sf https://packages.twingate.com/apt/Packages | awk '/^Version:/ {print $2}' | sort -V | tail -1)
        if [ -z "$VERSION" ]; then
          echo "Failed to fetch version, proceeding without cache"
          echo "version=unknown" >> $GITHUB_OUTPUT
        else
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Latest Twingate version: $VERSION"
        fi

        # Get OS version for cache key
        OS_VERSION=$(grep VERSION_ID /etc/os-release | cut -d= -f2 | tr -d '"')
        echo "os_version=$OS_VERSION" >> $GITHUB_OUTPUT

    - name: Get latest Twingate version (Windows)
      if: runner.os == 'Windows'
      id: twingate-version-windows
      shell: powershell
      run: |
        try {
          $response = Invoke-WebRequest -Uri "https://api.twingate.com/download/windows?installer=msi" -Method Head -MaximumRedirection 0 -ErrorAction SilentlyContinue
          $url = $response.Headers.Location
          if ($url) {
            $version = $url -replace '.*twingate-client-([\d.]+)\.msi.*', '$1'
            if ($version -and $version -ne $url) {
              Write-Host "Latest Twingate version: $version"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "version=$version"
            } else {
              Write-Host "Failed to extract version from URL"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "version=unknown"
            }
          } else {
            Write-Host "Failed to get download URL"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "version=unknown"
          }
        } catch {
          Write-Host "Failed to fetch version: $_"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "version=unknown"
        }

        # Get Windows version for cache key (e.g., "2022", "2025")
        $osVersion = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").ReleaseId
        if (-not $osVersion) {
          $osVersion = (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").CurrentBuildNumber
        }
        Add-Content -Path $env:GITHUB_OUTPUT -Value "os_version=$osVersion"

    - name: Setup cache directory (Linux)
      if: runner.os == 'Linux' && steps.twingate-version-linux.outputs.version != 'unknown'
      shell: bash
      run: mkdir -p ~/.twingate-cache

    - name: Cache Twingate package and dependencies (Linux)
      if: runner.os == 'Linux' && steps.twingate-version-linux.outputs.version != 'unknown'
      uses: actions/cache@v5
      id: cache-twingate-linux
      with:
        path: ~/.twingate-cache
        key: twingate-cache-v2-${{ runner.os }}-${{ runner.arch }}-${{ steps.twingate-version-linux.outputs.os_version }}-v${{ steps.twingate-version-linux.outputs.version }}

    - name: Setup cache directory (Windows)
      if: runner.os == 'Windows' && steps.twingate-version-windows.outputs.version != 'unknown'
      shell: powershell
      run: |
        $cacheDir = "$env:TEMP\twingate-cache"
        if (-not (Test-Path $cacheDir)) {
          New-Item -ItemType Directory -Path $cacheDir -Force | Out-Null
        }

    - name: Cache Twingate MSI (Windows)
      if: runner.os == 'Windows' && steps.twingate-version-windows.outputs.version != 'unknown'
      uses: actions/cache@v5
      id: cache-twingate-windows
      with:
        path: ${{ env.TEMP }}\twingate-cache
        key: twingate-msi-v2-${{ runner.os }}-${{ runner.arch }}-${{ steps.twingate-version-windows.outputs.os_version }}-v${{ steps.twingate-version-windows.outputs.version }}

    - name: Validate cached package (Linux)
      if: runner.os == 'Linux' && steps.cache-twingate-linux.outputs.cache-hit == 'true'
      id: validate-cache-linux
      shell: bash
      run: |
        DEB_FILE=$(ls ~/.twingate-cache/twingate*.deb 2>/dev/null | head -1)
        if [ -z "$DEB_FILE" ]; then
          echo "No .deb file found in cache"
          echo "valid=false" >> $GITHUB_OUTPUT
        elif ! dpkg-deb --info "$DEB_FILE" >/dev/null 2>&1; then
          echo "Cached .deb is corrupted"
          rm -rf ~/.twingate-cache/*
          echo "valid=false" >> $GITHUB_OUTPUT
        else
          echo "Cache is valid"
          echo "valid=true" >> $GITHUB_OUTPUT
        fi

    - name: Validate cached MSI (Windows)
      if: runner.os == 'Windows' && steps.cache-twingate-windows.outputs.cache-hit == 'true'
      id: validate-cache-windows
      shell: powershell
      run: |
        $cacheDir = "$env:TEMP\twingate-cache"
        $msiFiles = Get-ChildItem -Path $cacheDir -Filter "twingate*.msi" -ErrorAction SilentlyContinue

        if ($msiFiles.Count -eq 0) {
          Write-Host "No MSI file found in cache"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=false"
        } else {
          try {
            $msiFile = $msiFiles[0].FullName
            $validMsi = $true

            # Try to get MSI properties - this validates the MSI file
            $msiInfo = Get-ItemProperty -Path $msiFile
            if (-not $msiInfo) {
              Write-Host "Cached MSI is corrupted"
              Remove-Item -Path $cacheDir -Recurse -Force -ErrorAction SilentlyContinue
              Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=false"
            } else {
              Write-Host "Cache is valid"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=true"
            }
          } catch {
            Write-Host "Cached MSI is corrupted: $_"
            Remove-Item -Path $cacheDir -Recurse -Force -ErrorAction SilentlyContinue
            Add-Content -Path $env:GITHUB_OUTPUT -Value "valid=false"
          }
        }

    - name: Install Twingate from cache (Linux)
      if: runner.os == 'Linux' && steps.validate-cache-linux.outputs.valid == 'true'
      shell: bash
      run: |
        echo "Installing Twingate from cache"
        # Install all packages from cache directory (twingate + dependencies)
        sudo dpkg -i ~/.twingate-cache/*.deb || true
        sudo apt-get install -f -yq

    - name: Install Twingate from cache (Windows)
      if: runner.os == 'Windows' && steps.validate-cache-windows.outputs.valid == 'true'
      shell: powershell
      run: |
        Write-Host "Installing Twingate from cache"
        $cacheDir = "$env:TEMP\twingate-cache"
        $msiFile = Get-ChildItem -Path $cacheDir -Filter "twingate*.msi" | Select-Object -First 1

        if ($msiFile) {
          Write-Host "Using cached MSI: $($msiFile.Name)"
          Copy-Item -Path $msiFile.FullName -Destination ".\twingate_client.msi" -Force
        } else {
          Write-Host "No cached MSI found, will download"
          exit 1
        }

    - name: Install Twingate (Linux)
      if: runner.os == 'Linux' && (steps.cache-twingate-linux.outputs.cache-hit != 'true' || steps.validate-cache-linux.outputs.valid != 'true' || steps.twingate-version-linux.outputs.version == 'unknown')
      shell: bash
      run: |
        # Import Twingate GPG key for signature verification
        curl -fsSL https://packages.twingate.com/apt/gpg.key | sudo gpg --dearmor -o /usr/share/keyrings/twingate-client-keyring.gpg

        # Add Twingate repository with GPG key verification
        echo "deb [signed-by=/usr/share/keyrings/twingate-client-keyring.gpg] https://packages.twingate.com/apt/ * *" | sudo tee /etc/apt/sources.list.d/twingate.list

        sudo apt update
        sudo apt-get update -o Dir::Etc::sourcelist="sources.list.d/twingate.list" -o Dir::Etc::sourceparts="-" -o APT::Get::List-Cleanup="0"

        # Download all packages to cache if caching is enabled
        if [ "${{ steps.twingate-version-linux.outputs.version }}" != "unknown" ]; then
          mkdir -p ~/.twingate-cache
          # Download Twingate and all dependencies to cache directory
          # Using sudo -E to preserve HOME and proper permissions
          sudo -E apt-get install -yq --download-only -o Dir::Cache::Archives="$HOME/.twingate-cache" twingate
          # Install to resolve any missing dependencies, then download them
          sudo -E apt-get install -yq --download-only -o Dir::Cache::Archives="$HOME/.twingate-cache" -f
          # Fix permissions so cache action can save files
          sudo chown -R $(id -u):$(id -g) ~/.twingate-cache
        fi

        sudo apt install -yq twingate

    - name: Install and Start Twingate (Windows)
      if: runner.os == 'Windows' && (steps.cache-twingate-windows.outputs.cache-hit != 'true' || steps.validate-cache-windows.outputs.valid != 'true' || steps.twingate-version-windows.outputs.version == 'unknown')
      shell: powershell
      run: |
        # Download MSI
        $msiUrl = "https://api.twingate.com/download/windows?installer=msi"
        Write-Host "Downloading Twingate from $msiUrl"
        Invoke-WebRequest -Uri $msiUrl -OutFile ".\twingate_client.msi"

        # Cache the MSI if caching is enabled
        if ('${{ steps.twingate-version-windows.outputs.version }}' -ne 'unknown') {
          $cacheDir = "$env:TEMP\twingate-cache"
          if (-not (Test-Path $cacheDir)) {
            New-Item -ItemType Directory -Path $cacheDir -Force | Out-Null
          }

          $version = '${{ steps.twingate-version-windows.outputs.version }}'
          $msiCachePath = "$cacheDir\twingate-client-$version.msi"
          Write-Host "Caching MSI to $msiCachePath"
          Copy-Item -Path ".\twingate_client.msi" -Destination $msiCachePath -Force
        }
    
    - name: Setup and start Twingate (Linux)
      if: runner.os == 'Linux'
      shell: bash
      run: |
        echo '${{ inputs.service-key }}' | sudo twingate setup --headless -
        MAX_RETRIES=5
        WAIT_TIME=5
        n=0

        while [ $n -lt $MAX_RETRIES ]; do
          echo "Starting Twingate service..."
          set +xe
          twingate start

          echo "Waiting $WAIT_TIME seconds for Twingate service to start..."
          sleep $WAIT_TIME

          status=$(twingate status)
          echo "Twingate service status: '$status'"

          if [ "$status" = "online" ]; then
            echo "Twingate service is connected."
            if [ "${{ inputs.debug }}" != "false" ]; then
              twingate resources
            fi
            break
          else
            twingate stop
            if [ "${{ inputs.debug }}" != "false" ]; then
              journalctl -u twingate --no-pager
            fi
          fi

          # Increment the retry counter and wait time
          n=$((n+1))
          WAIT_TIME=$((WAIT_TIME+5))

          echo "Twingate service is not connected. Retrying ..."
        done

        if [ $n -eq $MAX_RETRIES ]; then
          echo "Twingate service failed to connect."
          exit 1
        fi

    - name: Setup and Start Twingate (Windows)
      if: runner.os == 'Windows'
      shell: powershell
      run: |
        # Install the Twingate service
        Set-Content .\key.json  '${{ inputs.service-key }}'
        $key_path = (Get-Item .\key.json | Resolve-Path).ProviderPath

        Start-Process msiexec.exe -Wait -ArgumentList "/i twingate_client.msi /l*v install.log log_level=debug service_secret=$key_path /quiet"

        Start-Sleep -Seconds 1
        Start-Service twingate.service

        Start-Sleep -Seconds 14
        Get-Service twingate.service